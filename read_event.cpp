
/*
 * mpu6050 UserSpace Six-axis IMU driver logging
 *
 * Copyright (C) 2018  Juan Jos√© Tarrio <juan.tarrio@gmail.com>
 *
 * Reads the MPU6050 on the linux event interface generated by the driver
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 *
 */

#include <linux/input.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <iomanip>
#include <fstream>
#include <signal.h>
#include <sstream>
#include <iostream>


bool run=true;
void sigexit(int p){
    run=false;
}

int main(int argc,char*argv[]){

    if(argc<2){

        std::cout <<"Use: read_event EVENT_FILENAME\n";
        return -1;
    }
    int joy_fd;

    if( ( joy_fd = open( argv[1], O_RDONLY)) == -1 )
    {
        printf( "\nNo puedo abrir el dispocitivo de entrada\n" );

        return -1;

    }


    std::stringstream stringbuf;
    stringbuf.str().reserve(1e6);

    input_event ev;

    int ax=0,ay=0,az=0,gx=0,gy=0,gz=0,t=0;

    signal(SIGINT,sigexit);

    int pc=0;

    while(run){

        if(read(joy_fd, &ev, sizeof(input_event))==sizeof(input_event)){

            if(ev.type==EV_ABS){
                switch(ev.code){
                case ABS_X:
                    ax=ev.value;
                    break;
                case ABS_Y:
                    ay=ev.value;
                    break;
                case ABS_Z:
                    az=ev.value;
                    break;
                case ABS_RX:
                    gx=ev.value;
                    break;
                case ABS_RY:
                    gy=ev.value;
                    break;
                case ABS_RZ:
                    gz=ev.value;
                    break;
                case ABS_THROTTLE:
                    t=ev.value;
                    break;
                }

            }else if(ev.type==EV_SYN){

                if(ev.code==SYN_REPORT){
                    double time=ev.time.tv_sec+ev.time.tv_usec*1.0e-6;
                    stringbuf<<std::setprecision(20)<<time<<" "<<ax<<" "<<ay<<" "<<az<<" "<<gx<<" "<<gy<<" "<<gz<<" "<<t<<"\n";
                    if(++pc==10){
                         pc=0;

                         //printf("Event Code: %d, Value: %d\n",ev.code,ev.value);
                         printf("A: (% 6d,% 6d,% 6d) G: (% 6d,% 6d,% 6d) Temp: %f\r",ax,ay,az,gx,gy,gz,float(t)/340.0+36.53);
                         fflush(stdout);
                     }

                }else{
                    std::cout <<"SynEvent: "<<ev.code<<"\n";
                }

            }

        }
    }

    close(joy_fd);



    std::ofstream logfile("log.txt");

    assert(logfile.is_open());

    logfile<<stringbuf.str();

    logfile.close();

    printf("exit...\n");

    return 0;
}
